<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>$FLIPPED — Flip Everything</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <style>
    :root{
      --bg:#0b0d10; --panel:#12151a; --panel-2:#0f1317; --grid:#1a1f26;
      --text:#e9eef6; --muted:#9aa7b3; --neon:#39ff88; --neon-soft:rgba(57,255,136,.18);
      --danger:#ff4d4d; --accent:#40d1ff; --gold:#d4af37;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(80vw 80vh at 50% -10%, rgba(57,255,136,.08), transparent 45%),
                  radial-gradient(60vw 60vh at -10% 120%, rgba(64,209,255,.06), transparent 40%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow-x:hidden;
    }
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none; opacity:.25;
      background:linear-gradient(transparent 31px, var(--grid) 32px),
                 linear-gradient(90deg, transparent 31px, var(--grid) 32px);
      background-size:32px 32px, 32px 32px;
      mask: linear-gradient(#000, transparent 65%);
      animation: drift 30s linear infinite;
    }
    @keyframes drift{from{transform:translateY(0)} to{transform:translateY(32px)}}

    .wrap{max-width:1200px; margin:0 auto; padding:24px 20px 96px}

    .topbar{display:flex; flex-direction:column; align-items:center; gap:18px; margin-bottom:20px}
    .btns{display:flex; gap:12px; justify-content:center}
    .btn{
      position:relative; isolation:isolate; border:1px solid var(--grid);
      background:linear-gradient(180deg, var(--panel), var(--panel-2));
      color:var(--text); padding:12px 18px; border-radius:999px; letter-spacing:.08em; text-transform:uppercase; font-weight:700;
      box-shadow:0 0 0 0 var(--neon-soft), inset 0 0 20px rgba(255,255,255,.02);
      transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease; text-decoration:none;
    }
    .btn:hover{ transform:translateY(-1px); border-color:var(--neon); box-shadow:0 0 24px -6px var(--neon-soft), inset 0 0 24px rgba(255,255,255,.04)}
    .btn:active{ transform:translateY(0)}
    .btn.x{ padding:12px 22px }
    .btn.buy{ background:linear-gradient(180deg, #0f1a14, #0c1511); border-color:rgba(57,255,136,.35)}
    .btn .shine{position:absolute; inset:-2px; border-radius:999px; background: conic-gradient(from 0deg, transparent 0 82%, rgba(57,255,136,.5) 84% 86%, transparent 88% 100%);
      filter:blur(8px); opacity:.0; transition:opacity .25s ease; z-index:-1; animation:spin 3s linear infinite}
    .btn:hover .shine{opacity:.6}
    @keyframes spin{to{transform:rotate(360deg)}}

    .kpis{display:grid; grid-template-columns: 1fr minmax(260px, 420px); gap:16px; align-items:stretch}
    .kpi, .latest{
      position:relative; background:linear-gradient(180deg, rgba(25,29,36,.9), rgba(16,19,24,.9));
      border:1px solid var(--grid); border-radius:16px; padding:18px 18px 16px; overflow:hidden;
    }
    .kpi::before, .latest::before{
      content:""; position:absolute; inset:0; border-radius:16px; pointer-events:none;
      background:radial-gradient(100% 60% at 0% 0%, rgba(57,255,136,.12), transparent 40%),
                 radial-gradient(80% 80% at 100% 0%, rgba(64,209,255,.08), transparent 40%);
    }
    .label{font-size:.78rem; letter-spacing:.12em; color:var(--muted); text-transform:uppercase}
    .value{font-size:2rem; font-weight:800; letter-spacing:.02em; margin-top:6px}
    .sub{color:var(--muted); font-size:.9rem}

    .latest .itemline{display:flex; gap:12px; align-items:center; margin-top:10px}
    .imgph{width:44px; height:44px; border-radius:10px; display:grid; place-items:center; font-size:24px; background:#121a15; border:1px solid rgba(57,255,136,.25); box-shadow: inset 0 0 18px rgba(57,255,136,.1)}
    .title{font-weight:700}
    .cash{margin-left:auto; font-weight:800; color:var(--neon)}

    .items{margin-top:18px; display:grid; grid-template-columns:1fr; gap:10px}
    @media(min-width:860px){ .items{ grid-template-columns: 1fr 1fr } }

    .card{position:relative; display:grid; grid-template-columns:64px 1fr auto; align-items:center; gap:14px; padding:12px; border-radius:14px; border:1px solid var(--grid);
      background:linear-gradient(180deg, var(--panel), var(--panel-2));
      transition:border-color .2s ease, transform .2s ease, box-shadow .2s ease; overflow:hidden}
    .card:hover{ border-color:var(--neon); transform:translateY(-1px); box-shadow:0 10px 30px -18px var(--neon-soft)}
    .card .imgph{width:56px; height:56px; font-size:26px}
    .card .desc{color:var(--muted); font-size:.95rem; margin-top:4px}
    .card .price{font-weight:900; font-size:1.1rem; color:var(--neon)}

    .card.flipped{ filter:saturate(.25) brightness(.75); border-color:#2a2f35; }
    .card.flipped::after{
      content:"FLIPPED"; position:absolute; right:12px; top:12px; padding:4px 8px; border:1px solid rgba(57,255,136,.35); color:var(--neon); border-radius:999px; font-weight:800; font-size:.72rem; letter-spacing:.1em; background:rgba(57,255,136,.08);
      animation: pop .35s ease; box-shadow:0 0 24px -6px var(--neon-soft);
    }
    @keyframes pop{ from{ transform:scale(.8); opacity:.0 } to{ transform:scale(1); opacity:1 } }

    .card .runner, .kpi .runner, .latest .runner{ position:absolute; height:2px; width:40%; background:linear-gradient(90deg, transparent, var(--neon), transparent); opacity:.7; filter:blur(.5px) }
    .card .runner{ top:-1px; left:0; animation:run 3.6s linear infinite }
    .kpi .runner{ bottom:-1px; right:0; animation:run 4.2s linear infinite reverse }
    .latest .runner{ top:-1px; right:0; animation:run 4.8s linear infinite }
    @keyframes run{ from{ transform:translateX(-60%) } to{ transform:translateX(160%) } }

    .scan{ position:absolute; inset:0; pointer-events:none; background:linear-gradient(120deg, transparent 0%, rgba(255,255,255,.05) 10%, transparent 20%); transform:translateX(-120%); }
    .card.flipped .scan{ animation: sweep 900ms ease forwards }
    @keyframes sweep{ to{ transform:translateX(120%) } }

    .ticker{ position:sticky; top:0; z-index:5; margin-bottom:12px }
    .marquee{ overflow:hidden; border:1px solid var(--grid); border-radius:12px; background:linear-gradient(180deg, var(--panel), var(--panel-2)); }
    .track{ display:flex; gap:36px; padding:8px 12px; white-space:nowrap; animation: marquee 30s linear infinite }
    .pill{ font-size:.8rem; letter-spacing:.1em; color:var(--muted) }
    .dot{ width:6px; height:6px; background:var(--neon); border-radius:999px; display:inline-block; box-shadow:0 0 10px var(--neon) }
    @keyframes marquee{ from{ transform:translateX(0) } to{ transform:translateX(-50%) } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="ticker">
      <div class="marquee">
        <div class="track" id="tickerTrack"></div>
      </div>
    </div>

    <div class="topbar">
      <div class="btns">
        <a class="btn x" href="https://x.com/flippedcoinsol" id="xLink" aria-label="Go to X"><span class="shine"></span> X</a>
        <a class="btn buy" href="https://pump.fun/" id="buyLink" aria-label="Buy $FLIP"><span class="shine"></span> BUY</a>
      </div>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="runner"></div>
        <div class="label">$FLIPPED Market Cap</div>
        <div class="value" id="mcValue">$0</div>
        <div class="sub"><span class="dot"></span> systems up</div>
      </div>
      <div class="latest">
        <div class="runner"></div>
        <div class="label">Just Flipped</div>
        <div class="itemline" id="latestFlip">
          <div class="imgph">🌀</div>
          <div>
            <div class="title">Nothing… yet</div>
            <div class="sub">When MC ≥ item value, we flip it automatically.</div>
          </div>
          <div class="cash">$0</div>
        </div>
      </div>
    </div>

    <div class="items" id="items"></div>
  </div>

<script>
  /******************************
   * $FLIPPED — Core Page Script
   ******************************/

  // ---- API bridge to your server ----
  async function fetchMarketCapOnce(signal){
    const resp = await fetch('/api/mc', {
      cache: 'no-store',
      signal,
      keepalive: true,
      headers: { 'cache-control':'no-cache', 'pragma':'no-cache' }
    });
    if(!resp.ok) return null;
    const data = await resp.json();
    return (typeof data?.mc === 'number' && isFinite(data.mc)) ? { mc: data.mc, ok: !!data.ok, t: data.lastUpdated || Date.now() } : null;
  }

  const fmt = new Intl.NumberFormat('en-US', { style:'currency', currency:'USD', maximumFractionDigits:0 });

  // Items (unchanged) ...
  const items = [/* ... your items array exactly as before ... */];

  // Build ticker
  const track = document.getElementById('tickerTrack');
  const tickPhrases = Array(8).fill("ca: .....pump •");
  for(let i=0;i<2;i++) tickPhrases.forEach(p=>{
    const span=document.createElement('span'); span.className='pill'; span.textContent=p; track.appendChild(span);
  });

  // Build cards
  const itemsRoot = document.getElementById('items');
  items.sort((a,b)=>a.v-b.v);
  items.forEach((it, idx)=>{
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.value = it.v;
    card.dataset.index = idx;
    card.innerHTML = `
      <div class="imgph">${it.e}</div>
      <div>
        <div class="title">${it.t}</div>
        <div class="desc">${it.d}</div>
      </div>
      <div class="price">${fmt.format(it.v)}</div>
      <div class="runner"></div>
      <div class="scan"></div>
    `;
    itemsRoot.appendChild(card);
  });

  /* === Permanent flipped state (persist across sessions) + migration === */
  const FLIPPED_KEY = 'flip.flipped.v6';
  function loadFlipped() {
    const raw = JSON.parse(localStorage.getItem(FLIPPED_KEY) || '[]');
    const idxs = [];
    for (const x of raw) {
      if (typeof x !== 'number') continue;
      if (x >= 0 && x < items.length) idxs.push(x);
      else {
        const i = items.findIndex(it => it.v === x);
        if (i !== -1) idxs.push(i);
      }
    }
    return new Set(idxs);
  }
  const flippedSet = loadFlipped();
  function saveFlipped(){ localStorage.setItem(FLIPPED_KEY, JSON.stringify([...flippedSet])); }
  function applyFlippedFromStorage(){
    document.querySelectorAll('.card').forEach(card=>{
      const idx = Number(card.dataset.index);
      if (flippedSet.has(idx)) card.classList.add('flipped');
    });
  }
  function computeLatestFromState(){
    let best = null, bestV = -1, bestIdx = -1;
    document.querySelectorAll('.card.flipped').forEach(card=>{
      const v = Number(card.dataset.value);
      const idx = Number(card.dataset.index);
      if (v > bestV) { bestV = v; bestIdx = idx; }
    });
    if (bestIdx >= 0) best = items[bestIdx];
    return best;
  }
  applyFlippedFromStorage();

  // State + logic
  let marketCap = 0;
  let latest = null;
  const mcValueEl = document.getElementById('mcValue');
  const latestFlipEl = document.getElementById('latestFlip');
  const statusEl = document.querySelector('.kpi .sub'); // shows “systems up” etc.

  // initialize "latest" on load based on storage
  const initLatest = computeLatestFromState();
  if (initLatest) { latest = initLatest; updateLatest(initLatest); }

  function setMarketCap(val){
    const next = Math.max(0, Number(val)||0);
    if (next === marketCap) return; // no DOM churn if same number
    marketCap = next;
    mcValueEl.textContent = fmt.format(marketCap);

    const cards = [...document.querySelectorAll('.card')];
    let flippedSomething = false;
    let localLatest = null;

    for (const card of cards){
      const v = Number(card.dataset.value);
      const idx = Number(card.dataset.index);
      if(v <= marketCap && !card.classList.contains('flipped')){
        card.classList.add('flipped');
        flippedSet.add(idx);
        flippedSomething = true;
        localLatest = items[idx];
      }
      // Never unflip on dips.
    }
    if (flippedSomething) saveFlipped();

    if(flippedSomething && localLatest){
      latest = localLatest;
      updateLatest(localLatest);
    } else {
      const best = computeLatestFromState();
      if (best && (!latest || best.v !== latest.v)) {
        latest = best;
        updateLatest(best);
      }
    }
  }

  function updateLatest(it){
    latestFlipEl.innerHTML = `
      <div class="imgph">${it.e}</div>
      <div>
        <div class="title">${it.t}</div>
        <div class="sub">We just flipped this. Next target loading…</div>
      </div>
      <div class="cash">${fmt.format(it.v)}</div>
    `;
    latestFlipEl.animate(
      [{ transform:'scale(1)', boxShadow:'none' },
       { transform:'scale(1.02)', boxShadow:'0 0 40px -10px var(--neon-soft)' },
       { transform:'scale(1)' }],
      { duration:600, easing:'ease' }
    );
  }

  function setStatus(ok, lastUpdated){
    const age = Date.now() - (lastUpdated || 0);
    const stale = age > 10_000 || !ok;
    // only touch DOM if it changes
    const next = `<span class="dot"></span> ${stale ? 'degraded' : 'systems up'}`;
    if (statusEl && statusEl.innerHTML !== next) statusEl.innerHTML = next;
  }

  // ---------- Precise 2s poller with hard timeout & no overlap ----------
  const PERIOD_MS = 2000;
  const HARD_TIMEOUT_MS = 1900; // abort client-side before next tick
  let visible = true;

  async function pollTick(scheduleAt){
    const controller = new AbortController();
    const kill = setTimeout(() => controller.abort(), HARD_TIMEOUT_MS);

    try {
      const data = await fetchMarketCapOnce(controller.signal);
      if (data && data.mc > 0) setMarketCap(data.mc);
      setStatus(!!data?.ok, data?.t);
    } catch(e) {
      if (e.name !== 'AbortError') console.warn('poll error', e);
      // keep showing last value; status will flip to degraded on server side if needed
    } finally {
      clearTimeout(kill);
      // schedule next tick for exact cadence
      const now = performance.now();
      const nextAt = scheduleAt + PERIOD_MS;
      const delay = Math.max(0, nextAt - now);
      if (visible) setTimeout(() => pollTick(nextAt), delay);
    }
  }

  // Visibility-aware (don’t waste credits when hidden)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      visible = false;
    } else {
      // resume immediately on focus
      visible = true;
      const startAt = performance.now();
      pollTick(startAt);
    }
  });

  // Initial fetch then precise cadence
  (async ()=>{
    try{
      const controller = new AbortController();
      const kill = setTimeout(() => controller.abort(), HARD_TIMEOUT_MS);
      const first = await fetchMarketCapOnce(controller.signal);
      clearTimeout(kill);
      if (first && first.mc > 0){
        setMarketCap(first.mc);
        setStatus(!!first.ok, first.t);
      }
    }catch{}
    const startAt = performance.now();
    pollTick(startAt);
  })();
</script>


</body>
</html>


